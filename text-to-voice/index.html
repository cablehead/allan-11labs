<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ElevenLabs TTS</title>
  <style>
    body { font-family: system-ui; margin: 2rem; max-width: 600px; }
    input, select, textarea, button { width: 100%; padding: 0.5rem; margin: 0.5rem 0; }
    .flex { display: flex; gap: 0.5rem; }
    .flex input { flex: 1; }
    .flex button { width: auto; padding: 0.5rem 1rem; }
    #log { font-family: monospace; background: #f5f5f5; padding: 0.5rem; height: 150px; overflow-y: auto; }
    button { background: #007bff; color: white; border: none; cursor: pointer; }
    button:disabled { background: #ccc; }
  </style>
</head>
<body>
  <h1>ElevenLabs TTS</h1>
  
  <p><em>Using TTS model: eleven_flash_v2_5</em></p>

  <label>API Key:</label>
  <div class="flex">
    <input type="password" id="apiKey" placeholder="Enter API key">
    <button id="clear">Clear</button>
  </div>
  
  <label>Voice:</label>
  <select id="voice" disabled><option>Enter API key first...</option></select>

  <label>Text:</label>
  <textarea id="text" placeholder="Enter text to convert...">Hello world! This is a test.</textarea>

  <button id="start" disabled>Generate Speech</button>
  <div id="log"></div>

  <script>
    const $ = id => document.getElementById(id);
    const apiKey = $('apiKey'), voice = $('voice'), text = $('text'), start = $('start'), log = $('log');
    let audioTime = 0;

    function addLog(msg) {
      const lines = log.textContent.split('\n').filter(Boolean);
      lines.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
      if (lines.length > 50) lines.splice(0, lines.length - 50);
      log.textContent = lines.join('\n');
      log.scrollTop = log.scrollHeight;
    }

    function updateButton() {
      start.disabled = !apiKey.value || !voice.value || !text.value.trim();
    }

    async function loadVoices() {
      try {
        voice.innerHTML = '<option>Loading...</option>';
        const res = await fetch('https://api.elevenlabs.io/v1/voices', {
          headers: { 'xi-api-key': apiKey.value }
        });
        const data = await res.json();
        
        voice.innerHTML = '<option value="">Select voice...</option>';
        data.voices.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.voice_id;
          opt.textContent = v.name;
          voice.appendChild(opt);
        });
        voice.disabled = false;
        addLog(`‚úì Loaded ${data.voices.length} voices`);
      } catch (e) {
        voice.innerHTML = '<option>Error loading</option>';
        addLog(`‚úó Error loading voices: ${e.message}`);
      }
      updateButton();
    }

    async function playAudio(audioData, ctx) {
      try {
        addLog(`üéµ Attempting to decode ${audioData.byteLength} bytes of audio data`);
        const buffer = await ctx.decodeAudioData(audioData);
        addLog(`‚úì Decoded: ${buffer.duration.toFixed(2)}s, ${buffer.sampleRate}Hz, ${buffer.numberOfChannels} channels`);
        
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        source.connect(ctx.destination);
        
        const startTime = Math.max(ctx.currentTime, audioTime);
        source.start(startTime);
        audioTime = startTime + buffer.duration;
        
        addLog(`üé∂ Started playback at ${startTime.toFixed(2)}s, next at ${audioTime.toFixed(2)}s`);
        
        source.onended = () => {
          addLog('‚úÖ Audio chunk playback completed');
        };
        
      } catch (e) {
        addLog(`‚ùå Audio decode/play error: ${e.message}`);
        console.error('Full audio error:', e, 'Data length:', audioData ? audioData.byteLength : 'null');
      }
    }

    apiKey.oninput = () => {
      if (apiKey.value.length > 20) {
        localStorage.elevenlabs_key = apiKey.value;
        addLog(`üîë API key entered (${apiKey.value.slice(0,4)}...${apiKey.value.slice(-4)})`);
        loadVoices();
      } else {
        voice.innerHTML = '<option>Enter API key first...</option>';
        voice.disabled = true;
        updateButton();
      }
    };

    voice.onchange = text.oninput = updateButton;

    $('clear').onclick = () => {
      delete localStorage.elevenlabs_key;
      apiKey.value = '';
      voice.innerHTML = '<option>Enter API key first...</option>';
      voice.disabled = true;
      addLog('üóëÔ∏è API key cleared');
      updateButton();
    };

    // Add iOS-specific AudioContext unlock
    document.addEventListener('touchstart', () => {
      // This will help unlock AudioContext on iOS
    }, { once: true });

    start.onclick = () => {
      start.disabled = true;
      audioTime = 0;
      addLog('üöÄ Starting TTS generation...');

      const ws = new WebSocket(`wss://api.elevenlabs.io/v1/text-to-speech/${voice.value}/stream-input?model_id=eleven_flash_v2_5`);
      const ctx = new (AudioContext || webkitAudioContext)();
      
      addLog(`üé§ AudioContext created, state: ${ctx.state}`);
      
      // Try to resume AudioContext if suspended (iOS requirement)
      if (ctx.state === 'suspended') {
        ctx.resume().then(() => {
          addLog(`üîÑ AudioContext resumed, new state: ${ctx.state}`);
        }).catch(e => {
          addLog(`‚ùå Failed to resume AudioContext: ${e.message}`);
        });
      }

      ws.onopen = () => {
        addLog('üîó Connected to ElevenLabs');
        ws.send(JSON.stringify({ text: " ", xi_api_key: apiKey.value }));
        setTimeout(() => {
          addLog(`üìù Streaming ${text.value.length} characters`);
          ws.send(JSON.stringify({ text: text.value }));
        }, 500);
        setTimeout(() => ws.send(JSON.stringify({ text: "" })), 1000);
      };

      ws.onmessage = async ({ data }) => {
        const msg = JSON.parse(data);
        if (msg.audio) {
          try {
            addLog(`üì¶ Received audio chunk: ${msg.audio.length} base64 chars`);
            const bytes = Uint8Array.from(atob(msg.audio), c => c.charCodeAt(0));
            addLog(`üî¢ Decoded to ${bytes.length} bytes`);
            await playAudio(bytes.buffer, ctx);
            addLog('‚ñ∂Ô∏è Playing audio chunk');
          } catch (audioError) {
            addLog(`‚ùå Audio processing error: ${audioError.message}`);
            console.error('Audio processing error:', audioError, 'Base64 length:', msg.audio.length);
          }
        }
        if (msg.isFinal) {
          addLog('‚úÖ Generation complete!');
          ws.close();
        }
        if (msg.error) {
          addLog(`‚ùå Server error: ${msg.error}`);
        }
      };

      ws.onclose = () => {
        start.disabled = false;
        addLog('üîå Connection closed');
      };
      ws.onerror = () => addLog('‚ùå WebSocket connection error');
    };

    // Load saved key
    if (localStorage.elevenlabs_key) {
      apiKey.value = localStorage.elevenlabs_key;
      addLog(`üìÅ Loaded saved API key (${localStorage.elevenlabs_key.slice(0,4)}...${localStorage.elevenlabs_key.slice(-4)})`);
      loadVoices();
    }
  </script>
</body>
</html>