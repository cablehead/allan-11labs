<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ElevenLabs Live TTS</title>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    label { display: block; margin: 0.5rem 0 0.2rem; }
    #log { font-family: monospace; white-space: pre-wrap; background: #f0f0f0; padding: 1rem; height: 200px; overflow-y: auto; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>Live ElevenLabs TTS</h1>

  <label>API Key:
    <div style="display: flex; gap: 5px; align-items: center;">
      <input type="password" id="apiKey" style="flex: 1;" placeholder="Paste your API key" />
      <button id="clearApiKey" style="padding: 5px 10px; font-size: 12px;" title="Clear saved API key">Clear</button>
    </div>
  </label>
  <label>Voice ID:
    <select id="voiceId" style="width: 100%;" disabled>
      <option value="">Enter API key first to load voices...</option>
    </select>
  </label>

  <button id="startBtn">Start Streaming</button>

  <div id="status"></div>
  <audio id="audio" autoplay></audio>

  <h2>Error Log (last 100 entries)</h2>
  <div id="log"></div>

  <script>
    const logDiv = document.getElementById('log');
    function log(msg) {
      const lines = logDiv.innerText.split('\n').filter(Boolean);
      lines.push(msg);
      if (lines.length > 100) lines.splice(0, lines.length - 100);
      logDiv.innerText = lines.join('\n');
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    async function loadVoices(apiKey) {
      const voiceSelect = document.getElementById('voiceId');
      try {
        voiceSelect.innerHTML = '<option value="">Loading voices...</option>';
        voiceSelect.disabled = true;
        
        const response = await fetch('https://api.elevenlabs.io/v1/voices', {
          headers: { 'xi-api-key': apiKey }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
        
        data.voices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.voice_id;
          option.textContent = `${voice.name} (${voice.category})`;
          voiceSelect.appendChild(option);
        });
        
        voiceSelect.disabled = false;
        log(`Loaded ${data.voices.length} voices.`);
      } catch (error) {
        voiceSelect.innerHTML = '<option value="">Error loading voices</option>';
        log('Error loading voices: ' + error.message);
      }
    }

    // Load saved API key on page load
    function loadSavedApiKey() {
      const savedApiKey = localStorage.getItem('elevenlabs_api_key');
      if (savedApiKey) {
        log(`üìÅ Loaded saved API key: ${savedApiKey.substring(0, 8)}... (${savedApiKey.length} chars)`);
        document.getElementById('apiKey').value = savedApiKey;
        if (savedApiKey.length > 20) {
          loadVoices(savedApiKey);
        }
      } else {
        log('üìÅ No saved API key found in localStorage');
      }
    }

    // Save API key to localStorage
    function saveApiKey(apiKey) {
      if (apiKey && apiKey.length > 20) {
        localStorage.setItem('elevenlabs_api_key', apiKey);
        log('API key saved for future sessions.');
      } else {
        localStorage.removeItem('elevenlabs_api_key');
      }
    }

    // Load voices when API key is entered
    document.getElementById('apiKey').addEventListener('input', (e) => {
      const apiKey = e.target.value.trim();
      saveApiKey(apiKey); // Save to localStorage
      
      if (apiKey.length > 20) { // Basic check for API key format
        loadVoices(apiKey);
      } else {
        const voiceSelect = document.getElementById('voiceId');
        voiceSelect.innerHTML = '<option value="">Enter API key first to load voices...</option>';
        voiceSelect.disabled = true;
      }
    });

    // Clear API key button
    document.getElementById('clearApiKey').addEventListener('click', () => {
      localStorage.removeItem('elevenlabs_api_key');
      document.getElementById('apiKey').value = '';
      const voiceSelect = document.getElementById('voiceId');
      voiceSelect.innerHTML = '<option value="">Enter API key first to load voices...</option>';
      voiceSelect.disabled = true;
      log('API key cleared from storage.');
    });

    // Load saved API key when page loads
    window.addEventListener('load', loadSavedApiKey);

    document.getElementById('startBtn').onclick = () => {
      const apiKey = document.getElementById('apiKey').value.trim();
      const voiceId = document.getElementById('voiceId').value.trim();
      const modelId = 'eleven_flash_v2_5'; // Hardcoded for optimal streaming performance
      
      // Debug logging for API key
      log(`üîë Full API Key: "${apiKey}"`);
      log(`üîë API Key length: ${apiKey.length}`);
      log(`üé§ Voice ID: ${voiceId}`);
      log(`ü§ñ Model: ${modelId}`);
      
      if (!apiKey || !voiceId) {
        log('ERROR: API Key and Voice ID selection are required.');
        return;
      }

      const wsUrl = `wss://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(voiceId)}/stream-input?model_id=${encodeURIComponent(modelId)}&optimize_streaming_latency=3&output_format=mp3_22050_32`;
      
      // WebSocket doesn't support custom headers in browser, so we'll include API key in first message
      const ws = new WebSocket(wsUrl);
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      let bufferQueue = Promise.resolve();
      let currentTime = 0;

      ws.onopen = () => {
        log('WebSocket open. Starting streaming immediately...');
        // Start streaming immediately - no separate BOS message needed
        streamText(ws);
      };

      ws.onerror = (err) => log('WebSocket error: ' + (err.message || 'Unknown error'));
      ws.onclose = (event) => log(`WebSocket closed. Code: ${event.code}, Reason: ${event.reason}`);

      ws.onmessage = async ({ data }) => {
        try {
          const msg = JSON.parse(data);
          log(`Received: ${msg.audio ? '[AUDIO_CHUNK]' : JSON.stringify(msg).substring(0, 100)}`);
          
          if (msg.audio) {
            log('Processing audio chunk...');
            const bytes = Uint8Array.from(atob(msg.audio), c => c.charCodeAt(0));
            bufferQueue = bufferQueue.then(() => playChunk(bytes, audioCtx));
          }
          
          // Only close on isFinal AND no more text is being sent
          if (msg.isFinal) {
            log('Received isFinal - stream ending naturally.');
            // Don't immediately close, let it finish processing
            setTimeout(() => {
              if (ws.readyState === WebSocket.OPEN) {
                ws.close();
                log('WebSocket closed after stream completion.');
              }
            }, 1000);
          }
          
          if (msg.error) {
            log('Server error: ' + msg.error);
          }
        } catch (e) {
          log('Message parsing error: ' + e.message);
        }
      };

      // Streaming will be initiated from ws.onopen after BOS message
    };

    async function streamText(ws) {
      if (ws.readyState !== WebSocket.OPEN) {
        log('WebSocket not ready for streaming');
        return;
      }
      
      const text = "Mom, I left my lunch box at the streetcar stop, my daughter said, voice full of worry. Don't worry, I replied softly, we'll stop by the bakery and get you something warm on the way home.";
      
      log('Starting text streaming...');
      
      // Send the first message with voice settings AND enough text to trigger generation (120+ chars)
      const firstChunk = text.substring(0, 130); // Ensure we meet the 120 char threshold
      const remainingText = text.substring(130);
      
      log(`Sending initial chunk (${firstChunk.length} chars): "${firstChunk}"`);
      ws.send(JSON.stringify({
        text: firstChunk,
        voice_settings: { 
          stability: 0.5, 
          similarity_boost: 0.8,
          style: 0.0,
          use_speaker_boost: true
        },
        generation_config: {
          chunk_length_schedule: [120, 160, 250, 290]
        },
        xi_api_key: apiKey,  // Include API key in first message
        try_trigger_generation: true
      }));
      
      // Wait a bit, then send remaining text in chunks
      await new Promise(r => setTimeout(r, 1000));
      
      if (remainingText && ws.readyState === WebSocket.OPEN) {
        log(`Sending remaining text (${remainingText.length} chars): "${remainingText}"`);
        ws.send(JSON.stringify({ 
          text: remainingText,
          try_trigger_generation: true
        }));
        
        await new Promise(r => setTimeout(r, 1000));
      }
      
      // Send EOS (End of Stream) - this tells ElevenLabs we're done
      if (ws.readyState === WebSocket.OPEN) {
        log('Sending EOS to finalize stream');
        ws.send(JSON.stringify({ text: '' }));
      }
    }

    async function playChunk(bytes, audioCtx) {
      try {
        // Ensure audio context is resumed (required for autoplay policy)
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
          log('Audio context resumed');
        }
        
        const arrayBuffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        const buffer = await audioCtx.decodeAudioData(arrayBuffer);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        src.connect(audioCtx.destination);
        
        // Schedule playback to maintain continuity
        const startTime = Math.max(audioCtx.currentTime, currentTime);
        src.start(startTime);
        currentTime = startTime + buffer.duration;
        
        log(`‚ñ∂Ô∏è Playing audio: ${buffer.duration.toFixed(2)}s (scheduled at ${startTime.toFixed(2)}s)`);
        
        // Log when audio actually starts
        src.onended = () => log('Audio chunk finished playing');
        
      } catch (e) {
        log('‚ùå Audio error: ' + e.message);
        log('Bytes length: ' + bytes.length);
      }
    }
  </script>
</body>
</html>