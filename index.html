<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ElevenLabs Live TTS</title>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    label { display: block; margin: 0.5rem 0 0.2rem; }
    #log { font-family: monospace; white-space: pre-wrap; background: #f0f0f0; padding: 1rem; height: 200px; overflow-y: auto; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>Live ElevenLabs TTS</h1>

  <label>API Key:
    <input type="password" id="apiKey" style="width: 100%;" placeholder="Paste your API key" />
  </label>
  <label>Voice ID:
    <select id="voiceId" style="width: 100%;" disabled>
      <option value="">Enter API key first to load voices...</option>
    </select>
  </label>

  <button id="startBtn">Start Streaming</button>

  <div id="status"></div>
  <audio id="audio" autoplay></audio>

  <h2>Error Log (last 100 entries)</h2>
  <div id="log"></div>

  <script>
    const logDiv = document.getElementById('log');
    function log(msg) {
      const lines = logDiv.innerText.split('\n').filter(Boolean);
      lines.push(msg);
      if (lines.length > 100) lines.splice(0, lines.length - 100);
      logDiv.innerText = lines.join('\n');
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    async function loadVoices(apiKey) {
      const voiceSelect = document.getElementById('voiceId');
      try {
        voiceSelect.innerHTML = '<option value="">Loading voices...</option>';
        voiceSelect.disabled = true;
        
        const response = await fetch('https://api.elevenlabs.io/v1/voices', {
          headers: { 'xi-api-key': apiKey }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
        
        data.voices.forEach(voice => {
          const option = document.createElement('option');
          option.value = voice.voice_id;
          option.textContent = `${voice.name} (${voice.category})`;
          voiceSelect.appendChild(option);
        });
        
        voiceSelect.disabled = false;
        log(`Loaded ${data.voices.length} voices.`);
      } catch (error) {
        voiceSelect.innerHTML = '<option value="">Error loading voices</option>';
        log('Error loading voices: ' + error.message);
      }
    }

    // Load voices when API key is entered
    document.getElementById('apiKey').addEventListener('input', (e) => {
      const apiKey = e.target.value.trim();
      if (apiKey.length > 20) { // Basic check for API key format
        loadVoices(apiKey);
      } else {
        const voiceSelect = document.getElementById('voiceId');
        voiceSelect.innerHTML = '<option value="">Enter API key first to load voices...</option>';
        voiceSelect.disabled = true;
      }
    });

    document.getElementById('startBtn').onclick = () => {
      const apiKey = document.getElementById('apiKey').value.trim();
      const voiceId = document.getElementById('voiceId').value.trim();
      const modelId = 'eleven_flash_v2_5'; // Hardcoded for optimal streaming performance
      if (!apiKey || !voiceId) {
        log('ERROR: API Key and Voice ID selection are required.');
        return;
      }

      const wsUrl = `wss://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(voiceId)}/stream-input?model_id=${encodeURIComponent(modelId)}&optimize_streaming_latency=3`;
      const ws = new WebSocket(wsUrl);
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      let bufferQueue = Promise.resolve();
      let currentTime = 0;

      ws.onopen = () => {
        log('WebSocket open.');
        // Send initial BOS (Begin of Stream) message
        ws.send(JSON.stringify({
          text: '',
          voice_settings: { 
            stability: 0.5, 
            similarity_boost: 0.8,
            style: 0.0,
            use_speaker_boost: true
          },
          generation_config: {
            chunk_length_schedule: [120, 160, 250, 290]
          },
          xi_api_key: apiKey
        }));
      };

      ws.onerror = (err) => log('WebSocket error: ' + (err.message || 'Unknown error'));
      ws.onclose = (event) => log(`WebSocket closed. Code: ${event.code}, Reason: ${event.reason}`);

      ws.onmessage = async ({ data }) => {
        try {
          const msg = JSON.parse(data);
          log(`Received message: ${JSON.stringify(msg).substring(0, 100)}...`);
          
          if (msg.audio) {
            log('Received audio chunk.');
            const bytes = Uint8Array.from(atob(msg.audio), c => c.charCodeAt(0));
            bufferQueue = bufferQueue.then(() => playChunk(bytes, audioCtx));
          }
          
          if (msg.isFinal) {
            log('Stream complete (isFinal). Closing WebSocket.');
            ws.close();
          }
          
          if (msg.error) {
            log('Error from server: ' + msg.error);
          }
        } catch (e) {
          log('Error parsing message: ' + e.message);
        }
      };

      // Wait for connection then start streaming
      setTimeout(() => {
        if (ws.readyState === WebSocket.OPEN) {
          streamText(ws);
        } else {
          log('WebSocket not ready, waiting...');
          ws.addEventListener('open', () => streamText(ws));
        }
      }, 100);
    };

    async function streamText(ws) {
      const text = "Mom, I left my lunch box at the streetcar stop, my daughter said, voice full of worry. Don't worry, I replied softly, we'll stop by the bakery and get you something warm on the way home.";
      
      // Send text in smaller chunks word by word
      const words = text.split(' ');
      let currentChunk = '';
      
      for (let i = 0; i < words.length; i++) {
        currentChunk += words[i] + ' ';
        
        // Send chunk every 3-5 words
        if ((i + 1) % 4 === 0 || i === words.length - 1) {
          log(`Sending chunk: ${currentChunk.trim()}`);
          ws.send(JSON.stringify({ 
            text: currentChunk.trim(),
            try_trigger_generation: true
          }));
          currentChunk = '';
          await new Promise(r => setTimeout(r, 200)); // Small delay between chunks
        }
      }
      
      // Send EOS (End of Stream)
      log('Sending EOS');
      ws.send(JSON.stringify({ text: '' }));
    }

    async function playChunk(bytes, audioCtx) {
      try {
        const buffer = await audioCtx.decodeAudioData(bytes.buffer);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        src.connect(audioCtx.destination);
        
        // Schedule playback to maintain continuity
        const startTime = Math.max(audioCtx.currentTime, currentTime);
        src.start(startTime);
        currentTime = startTime + buffer.duration;
        
        log(`Playing audio chunk: ${buffer.duration.toFixed(2)}s`);
      } catch (e) {
        log('Audio playback error: ' + e.message);
      }
    }
  </script>
</body>
</html>